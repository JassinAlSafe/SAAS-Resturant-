// page.tsx
"use client";

import React, { useState, useRef, useEffect, useMemo } from "react";
import { QueryClient, QueryClientProvider } from "@tanstack/react-query";
import { useShoppingList } from "./hooks/useShoppingList";
import { ShoppingListItem } from "@/lib/types";
import {
  Undo,
  PlusCircle,
  RefreshCw,
  AlertTriangle,
  ListFilter,
  BarChart3,
  ShoppingCart,
  EyeOff,
} from "lucide-react";
import { motion, AnimatePresence } from "framer-motion";
import { toast } from "./utils/toast";

// Import our components using the new struct
import {
  BatchActionsBar,
  EnhancedShoppingListTable,
  ShoppingListCharts,
  EmptyShoppingList,
  ShoppingListSummary,
  AccessibilityHelpers,
} from "./components";
import { ModernFilterBar } from "./components/filters";
import { AddItemModal } from "./components/modals";

// Import announcer from accessibility
import { announcer } from "./components/accessibility/helpers";

// Create a client
const queryClient = new QueryClient();

// Wrap the main content in the QueryClientProvider
export default function ShoppingListPage() {
  return (
    <QueryClientProvider client={queryClient}>
      <ShoppingListContent />
    </QueryClientProvider>
  );
}

function ShoppingListContent() {
  const [selectedItem, setSelectedItem] = useState<ShoppingListItem | null>(
    null
  );
  const [isAddModalOpen, setIsAddModalOpen] = useState(false);
  const [isEditModalOpen, setIsEditModalOpen] = useState(false);
  const [searchTerm, setSearchTerm] = useState("");
  const [selectedCategory, setSelectedCategory] = useState<string>("all");
  const [showPurchased, setShowPurchased] = useState(false);
  const [sortBy, setSortBy] = useState("date");
  const [sortDirection, setSortDirection] = useState<"asc" | "desc">("desc");
  const [showAnalytics, setShowAnalytics] = useState(false);
  const [lastAction, setLastAction] = useState<{
    type: string;
    item?: ShoppingListItem;
    id?: string;
  }>({ type: "" });
  const undoTimeoutRef = useRef<NodeJS.Timeout | null>(null);

  // State for batch selection
  const [selectedItems, setSelectedItems] = useState<ShoppingListItem[]>([]);

  const {
    shoppingList,
    categories,
    isLoading,
    error,
    addItem,
    updateItem,
    removeItem,
    markAsPurchased,
    generateList,
    isAddingItem,
    isUpdatingItem,
    isDeletingItem,
    isMarkingAsPurchased,
    isGeneratingList,
  } = useShoppingList();

  // Derived data
  const pendingItems = useMemo(
    () => shoppingList.filter((item) => !item.isPurchased),
    [shoppingList]
  );

  const purchasedItems = useMemo(
    () => shoppingList.filter((item) => item.isPurchased),
    [shoppingList]
  );

  const urgentItems = useMemo(
    () => shoppingList.filter((item) => item.isUrgent),
    [shoppingList]
  );

  const autoGeneratedItems = useMemo(
    () => shoppingList.filter((item) => item.isAutoGenerated),
    [shoppingList]
  );

  const shoppingPhase = useMemo(() => {
    if (pendingItems.length === 0) return "complete";
    if (pendingItems.length > 0 && purchasedItems.length > 0)
      return "in-progress";
    if (pendingItems.length > 0 && purchasedItems.length === 0)
      return "planning";
    return "empty";
  }, [pendingItems.length, purchasedItems.length]);

  // Filter and sort logic
  const filteredList = useMemo(
    () =>
      shoppingList.filter((item) => {
        const matchesSearch = item.name
          .toLowerCase()
          .includes(searchTerm.toLowerCase());
        const matchesCategory =
          selectedCategory === "all" || item.category === selectedCategory;
        const matchesPurchased = showPurchased ? true : !item.isPurchased;
        return matchesSearch && matchesCategory && matchesPurchased;
      }),
    [shoppingList, searchTerm, selectedCategory, showPurchased]
  );

  const sortedList = useMemo(
    () =>
      [...filteredList].sort((a, b) => {
        let comparison = 0;

        if (sortBy === "name") comparison = a.name.localeCompare(b.name);
        else if (sortBy === "category")
          comparison = a.category.localeCompare(b.category);
        else if (sortBy === "cost")
          comparison = a.estimatedCost - b.estimatedCost;
        else if (sortBy === "quantity") comparison = a.quantity - b.quantity;
        else if (sortBy === "urgency")
          comparison = a.isUrgent === b.isUrgent ? 0 : a.isUrgent ? -1 : 1;
        else
          comparison =
            new Date(b.addedAt).getTime() - new Date(a.addedAt).getTime(); // date sort

        return sortDirection === "asc" ? comparison : -comparison;
      }),
    [filteredList, sortBy, sortDirection]
  );

  // Total cost calculation
  const totalEstimatedCost = useMemo(
    () => shoppingList.reduce((sum, item) => sum + item.estimatedCost, 0),
    [shoppingList]
  );

  // Check if there are any pending operations
  const isPending =
    isAddingItem ||
    isUpdatingItem ||
    isDeletingItem ||
    isMarkingAsPurchased ||
    isGeneratingList;

  // Item management handlers
  const handleAddItem = () => {
    setSelectedItem(null);
    setIsAddModalOpen(true);
  };

  const handleEditItem = (item: ShoppingListItem) => {
    setSelectedItem(item);
    setIsEditModalOpen(true);
  };

  const handleDeleteItem = async (id: string) => {
    const itemToDelete = shoppingList.find((item) => item.id === id);
    await removeItem(id);

    if (itemToDelete) {
      setLastAction({ type: "delete", item: itemToDelete });

      // Clear any existing timeout
      if (undoTimeoutRef.current) {
        clearTimeout(undoTimeoutRef.current);
      }

      // Show toast with undo button
      toast.info(
        <div className="flex items-center gap-2">
          <span>Item deleted</span>
          <button
            onClick={handleUndoLastAction}
            className="flex items-center gap-1 px-2 py-1 text-sm bg-base-200 rounded hover:bg-base-300"
          >
            <Undo className="h-3 w-3" />
            Undo
          </button>
        </div>,
        {
          duration: 5000,
          screenReaderMessage: `${itemToDelete.name} deleted. Press the undo button to restore it.`,
          onDismiss: () => {
            // Reset last action when toast dismisses
            setLastAction({ type: "" });
          },
        }
      );

      // Set timeout to clear the last action
      undoTimeoutRef.current = setTimeout(() => {
        setLastAction({ type: "" });
      }, 5000);
    }
  };

  const handleTogglePurchased = async (id: string, isPurchased: boolean) => {
    const targetItem = shoppingList.find((item) => item.id === id);
    await markAsPurchased({ id, isPurchased });

    if (targetItem) {
      setLastAction({
        type: "purchase",
        id,
        item: targetItem,
      });

      // Clear any existing timeout
      if (undoTimeoutRef.current) {
        clearTimeout(undoTimeoutRef.current);
      }

      // Show toast with undo button
      toast.info(
        <div className="flex items-center gap-2">
          <span>
            {isPurchased ? "Marked as purchased" : "Marked as not purchased"}
          </span>
          <button
            onClick={handleUndoLastAction}
            className="flex items-center gap-1 px-2 py-1 text-sm bg-base-200 rounded hover:bg-base-300"
          >
            <Undo className="h-3 w-3" />
            Undo
          </button>
        </div>,
        {
          duration: 5000,
          screenReaderMessage: `${targetItem.name} ${
            isPurchased ? "marked as purchased" : "marked as not purchased"
          }. Press the undo button to revert.`,
          onDismiss: () => {
            // Reset last action when toast dismisses
            setLastAction({ type: "" });
          },
        }
      );

      // Set timeout to clear the last action
      undoTimeoutRef.current = setTimeout(() => {
        setLastAction({ type: "" });
      }, 5000);
    }
  };

  const handleUndoLastAction = async () => {
    if (lastAction.type === "delete" && lastAction.item) {
      await addItem({
        name: lastAction.item.name,
        quantity: lastAction.item.quantity,
        unit: lastAction.item.unit,
        category: lastAction.item.category,
        estimatedCost: lastAction.item.estimatedCost,
        isUrgent: lastAction.item.isUrgent,
        notes: lastAction.item.notes,
        isPurchased: lastAction.item.isPurchased,
        isAutoGenerated: lastAction.item.isAutoGenerated,
      });

      toast.success("Item restored successfully", {
        screenReaderMessage: `${lastAction.item.name} has been restored to the list.`,
      });
    } else if (
      lastAction.type === "purchase" &&
      lastAction.id &&
      lastAction.item
    ) {
      const newPurchaseState = !lastAction.item.isPurchased;
      await markAsPurchased({
        id: lastAction.id,
        isPurchased: newPurchaseState,
      });

      toast.success(
        `Item ${newPurchaseState ? "purchased" : "unpurchased"} state restored`,
        {
          screenReaderMessage: `${lastAction.item.name} has been ${
            newPurchaseState ? "marked as purchased" : "marked as not purchased"
          }.`,
        }
      );
    }

    // Clear the last action
    setLastAction({ type: "" });

    // Clear any existing timeout
    if (undoTimeoutRef.current) {
      clearTimeout(undoTimeoutRef.current);
      undoTimeoutRef.current = null;
    }
  };

  const handleGenerateList = async () => {
    await generateList();
    toast.success("Shopping list generated successfully");
  };

  // Handle toggling the analytics view
  const toggleAnalytics = () => {
    setShowAnalytics(!showAnalytics);

    // Announce to screen readers
    announcer.announce(
      `${!showAnalytics ? "Showing" : "Hiding"} analytics section`,
      "polite"
    );
  };

  // Clear all filters
  const clearFilters = () => {
    setSearchTerm("");
    setSelectedCategory("all");
    setSortBy("date");
    setSortDirection("desc");

    // Don't reset showPurchased as this is often a persistent preference

    toast.info("Filters cleared");
  };

  // Batch actions handlers
  const handleMarkSelectedPurchased = async (ids: string[]) => {
    for (const id of ids) {
      await markAsPurchased({ id, isPurchased: true });
    }

    toast.success(`${ids.length} items marked as purchased`);
    setSelectedItems([]);
  };

  const handleMarkSelectedUnpurchased = async (ids: string[]) => {
    for (const id of ids) {
      await markAsPurchased({ id, isPurchased: false });
    }

    toast.success(`${ids.length} items marked as unpurchased`);
    setSelectedItems([]);
  };

  const handleDeleteSelected = async (ids: string[]) => {
    for (const id of ids) {
      await removeItem(id);
    }

    toast.success(`${ids.length} items deleted`);
    setSelectedItems([]);
  };

  const handleMarkSelectedUrgent = async (ids: string[]) => {
    for (const id of ids) {
      const item = shoppingList.find((item) => item.id === id);
      if (item) {
        await updateItem({
          id,
          updates: { isUrgent: true },
        });
      }
    }

    toast.success(`${ids.length} items marked as urgent`);
    setSelectedItems([]);
  };

  const handleMarkSelectedNotUrgent = async (ids: string[]) => {
    for (const id of ids) {
      const item = shoppingList.find((item) => item.id === id);
      if (item) {
        await updateItem({
          id,
          updates: { isUrgent: false },
        });
      }
    }

    toast.success(`${ids.length} items marked as not urgent`);
    setSelectedItems([]);
  };

  // Cleanup timeouts on unmount
  useEffect(() => {
    return () => {
      if (undoTimeoutRef.current) {
        clearTimeout(undoTimeoutRef.current);
      }
    };
  }, []);

  // Clear selected items when filter changes
  useEffect(() => {
    setSelectedItems([]);
  }, [searchTerm, selectedCategory, showPurchased]);

  const [isShoppingMode, setIsShoppingMode] = useState(false);

  if (isLoading) {
    return (
      <div className="flex items-center justify-center min-h-[60vh]">
        <div className="flex flex-col items-center gap-4">
          <div className="loading loading-spinner loading-md text-primary"></div>
          <p className="text-lg font-medium">Loading shopping list...</p>
        </div>
      </div>
    );
  }

  if (error) {
    return (
      <div className="flex items-center justify-center min-h-[60vh]">
        <div className="card w-full max-w-md bg-base-100 shadow-sm">
          <div className="card-body bg-error bg-opacity-10">
            <h2 className="card-title text-error flex items-center gap-2">
              <AlertTriangle className="h-6 w-6" />
              Error Loading Shopping List
            </h2>
            <p>{error.message || "Please try again later"}</p>
            <div className="card-actions justify-end mt-4">
              <button
                onClick={() => window.location.reload()}
                className="btn btn-outline w-full"
              >
                Try Again
              </button>
            </div>
          </div>
        </div>
      </div>
    );
  }

  return (
    <motion.div
      initial={{ opacity: 0 }}
      animate={{ opacity: 1 }}
      transition={{ duration: 0.3 }}
      className="container mx-auto px-4 py-8 space-y-6 max-w-7xl"
      aria-labelledby="page-heading"
    >
      <h1 id="page-heading" className="sr-only">
        Shopping List Management
      </h1>

      {/* Header Section with Main Actions */}
      <div className="flex flex-col lg:flex-row justify-between items-start lg:items-center gap-4">
        <div>
          <h2 className="text-3xl font-bold">Shopping List</h2>
          <p className="text-base-content/60 mt-1">
            Manage your shopping items efficiently
          </p>
        </div>

        <div className="flex flex-wrap gap-3">
          <div
            className="tooltip"
            data-tip="Add a new item to your shopping list"
          >
            <button onClick={handleAddItem} className="btn btn-primary">
              <PlusCircle className="h-4 w-4 mr-2" />
              Add Item
            </button>
          </div>

          <div
            className="tooltip"
            data-tip="Auto-generate a shopping list based on your history"
          >
            <button
              onClick={handleGenerateList}
              className="btn btn-outline"
              disabled={isGeneratingList}
            >
              <RefreshCw
                className={`h-4 w-4 mr-2 ${
                  isGeneratingList ? "animate-spin" : ""
                }`}
              />
              {isGeneratingList ? "Generating..." : "Generate List"}
            </button>
          </div>

          <div
            className="tooltip"
            data-tip={`${
              showAnalytics ? "Hide" : "View"
            } shopping analytics and insights`}
          >
            <button onClick={toggleAnalytics} className="btn btn-ghost">
              <BarChart3 className="h-4 w-4 mr-2" />
              {showAnalytics ? "Hide Analytics" : "Show Analytics"}
            </button>
          </div>

          <div
            className="tooltip"
            data-tip={
              isShoppingMode
                ? "Return to normal view"
                : "Switch to a simplified view for when you're actively shopping"
            }
          >
            <button
              onClick={() => setIsShoppingMode(!isShoppingMode)}
              className={`btn btn-outline ${
                isShoppingMode
                  ? "bg-success/10 text-success border-success/20"
                  : ""
              }`}
            >
              {isShoppingMode ? (
                <>
                  <EyeOff className="h-4 w-4 mr-2" />
                  Exit Shopping Mode
                </>
              ) : (
                <>
                  <ShoppingCart className="h-4 w-4 mr-2" />
                  Shopping Mode
                </>
              )}
            </button>
          </div>
        </div>
      </div>

      {/* Summary Cards */}
      <ShoppingListSummary
        itemsCount={{
          total: shoppingList.length,
          purchased: purchasedItems.length,
          urgent: urgentItems.length,
          autoGenerated: autoGeneratedItems.length,
        }}
        totalEstimatedCost={totalEstimatedCost}
        shoppingPhase={shoppingPhase}
      />

      {/* Modern Filter Bar */}
      {/* <ModernFilterBar
        searchTerm={searchTerm}
        onSearchChange={setSearchTerm}
        selectedCategory={selectedCategory}
        onCategoryChange={setSelectedCategory}
        showPurchased={showPurchased}
        onShowPurchasedChange={setShowPurchased}
        categories={categories}
        sortBy={sortBy}
        onSortByChange={setSortBy}
        sortDirection={sortDirection}
        onSortDirectionChange={setSortDirection}
      /> */}

      {/* Main Shopping List */}
      <div className="card bg-base-100 shadow-sm relative">
        <div className="card-body pb-0">
          <div className="flex justify-between items-center">
            <div>
              <h2 className="card-title">Shopping Items</h2>
              <p className="text-base-content/60">
                {filteredList.length === 0
                  ? "No items match your current filters"
                  : `Showing ${filteredList.length} item${
                      filteredList.length === 1 ? "" : "s"
                    }`}
              </p>
            </div>
          </div>

          {shoppingList.length === 0 ? (
            <EmptyShoppingList
              onAddClick={handleAddItem}
              onRefreshClick={handleGenerateList}
            />
          ) : filteredList.length === 0 ? (
            <div className="flex flex-col items-center justify-center py-12 text-center">
              <ListFilter className="h-12 w-12 text-base-content/20 mb-4" />
              <h3 className="text-lg font-medium">No matching items</h3>
              <p className="text-base-content/60 max-w-md mt-2">
                Try changing your search terms or filters to see more items
              </p>
              <button className="btn btn-outline mt-4" onClick={clearFilters}>
                Clear All Filters
              </button>
            </div>
          ) : (
            <EnhancedShoppingListTable
              items={sortedList}
              onEditItem={handleEditItem}
              onDeleteItem={handleDeleteItem}
              onTogglePurchased={handleTogglePurchased}
              onAddItem={handleAddItem}
              sortBy={sortBy}
              sortDirection={sortDirection}
              onSortChange={setSortBy}
              onSortDirectionChange={setSortDirection}
              isDeleting={isDeletingItem}
              isUpdating={isUpdatingItem || isMarkingAsPurchased}
              selectedItems={selectedItems}
              setSelectedItems={setSelectedItems}
              isShoppingMode={isShoppingMode}
            />
          )}
        </div>
      </div>

      {/* Analytics Section (Conditionally Shown) */}
      <AnimatePresence>
        {showAnalytics && (
          <motion.div
            initial={{ opacity: 0, height: 0 }}
            animate={{ opacity: 1, height: "auto" }}
            exit={{ opacity: 0, height: 0 }}
            transition={{ duration: 0.3 }}
            className="overflow-hidden"
          >
            <div className="card bg-base-100 shadow-sm">
              <div className="card-body">
                <div className="flex justify-between items-center">
                  <h2 className="card-title">Shopping Analytics</h2>
                  <button
                    className="btn btn-ghost btn-sm"
                    onClick={toggleAnalytics}
                  >
                    Hide
                  </button>
                </div>
                <p className="text-base-content/60">
                  Insights and trends from your shopping habits
                </p>
                <ShoppingListCharts items={shoppingList} />
              </div>
            </div>
          </motion.div>
        )}
      </AnimatePresence>

      {/* Batch Actions Bar (shows when items are selected) */}
      <AnimatePresence>
        {selectedItems.length > 0 && (
          <BatchActionsBar
            selectedItems={selectedItems}
            onClearSelection={() => setSelectedItems([])}
            onMarkAllPurchased={handleMarkSelectedPurchased}
            onMarkAllUnpurchased={handleMarkSelectedUnpurchased}
            onDeleteAll={handleDeleteSelected}
            onMarkAllUrgent={handleMarkSelectedUrgent}
            onMarkAllNotUrgent={handleMarkSelectedNotUrgent}
            isProcessing={isPending}
          />
        )}
      </AnimatePresence>

      {/* Modals */}
      <>
        {/* Add Item Modal */}
        <AddItemModal
          isOpen={isAddModalOpen}
          onClose={() => setIsAddModalOpen(false)}
          onAddItem={async (item) => {
            await addItem(
              item as Omit<
                ShoppingListItem,
                | "id"
                | "addedAt"
                | "purchasedAt"
                | "userId"
                | "businessProfileId"
              >
            );
          }}
          categories={categories}
          isAddingItem={isAddingItem}
        />

        {/* Edit Item Modal */}
        {selectedItem && (
          <AddItemModal
            isOpen={isEditModalOpen}
            onClose={() => setIsEditModalOpen(false)}
            onAddItem={async (updates) => {
              await updateItem({ id: selectedItem.id, updates });
            }}
            categories={categories}
            isAddingItem={isUpdatingItem}
            initialData={selectedItem}
          />
        )}
      </>

      {/* Accessibility Helpers (Keep at the bottom) */}
      <AccessibilityHelpers
        items={sortedList}
        onItemSelect={handleEditItem}
        onItemPurchase={markAsPurchased}
      />
    </motion.div>
  );
}
