import { supabase } from "@/lib/supabase/browser-client";
import { ShoppingListItem, ShoppingListItemDB, mapDbToShoppingListItem } from "@/lib/types";

/**
 * Fetches the shopping list items from the database
 */
export async function fetchShoppingList(): Promise<ShoppingListItem[]> {
    try {
        const { data, error } = await supabase
            .from("shopping_list")
            .select(`
                id,
                name,
                quantity,
                unit,
                category,
                estimated_cost,
                is_auto_generated,
                is_purchased,
                inventory_item_id,
                added_at,
                purchased_at,
                user_id
            `)
            .order("added_at", { ascending: false });

        if (error) {
            console.error("Error in fetchShoppingList:", error.message);
            throw new Error(`Failed to fetch shopping list: ${error.message}`);
        }

        return data?.map(item => mapDbToShoppingListItem(item as ShoppingListItemDB)) || [];
    } catch (err) {
        console.error("Error in fetchShoppingList:", err);
        throw err;
    }
}

/**
 * Creates a new shopping list item
 */
export async function createShoppingItem(
    item: Omit<ShoppingListItem, "id" | "addedAt" | "purchasedAt">
): Promise<ShoppingListItem> {
    try {
        // Prepare the item data
        const itemData = {
            name: item.name,
            quantity: item.quantity,
            unit: item.unit,
            category: item.category,
            estimated_cost: item.estimatedCost || 0,
            is_auto_generated: item.isAutoGenerated ?? false,
            is_purchased: item.isPurchased ?? false,
            inventory_item_id: item.inventoryItemId || null,
            user_id: item.userId,
            added_at: new Date().toISOString()
        };

        const { data, error } = await supabase
            .from("shopping_list")
            .insert([itemData])
            .select()
            .single();

        if (error) {
            throw new Error(`Failed to create shopping item: ${error.message}`);
        }

        if (!data) {
            throw new Error("No data returned from create operation");
        }

        // Return the properly mapped data
        return mapDbToShoppingListItem(data as ShoppingListItemDB);
    } catch (err) {
        console.error("Error in createShoppingItem:", err);
        throw err;
    }
}

/**
 * Updates an existing shopping list item
 */
export async function updateShoppingItem(
    id: string,
    updates: Partial<Omit<ShoppingListItem, "id" | "addedAt" | "purchasedAt">>
): Promise<ShoppingListItem> {
    try {
        // Convert camelCase property names to snake_case for the database
        const dbUpdates: Record<string, string | number | boolean | null> = {};

        if (updates.name !== undefined) dbUpdates.name = updates.name;
        if (updates.quantity !== undefined) dbUpdates.quantity = updates.quantity;
        if (updates.unit !== undefined) dbUpdates.unit = updates.unit;
        if (updates.category !== undefined) dbUpdates.category = updates.category;
        if (updates.estimatedCost !== undefined) dbUpdates.estimated_cost = updates.estimatedCost;
        if (updates.isAutoGenerated !== undefined) dbUpdates.is_auto_generated = updates.isAutoGenerated;
        if (updates.isPurchased !== undefined) {
            dbUpdates.is_purchased = updates.isPurchased;
            if (updates.isPurchased) {
                dbUpdates.purchased_at = new Date().toISOString();
            } else {
                dbUpdates.purchased_at = null;
            }
        }
        if (updates.inventoryItemId !== undefined) dbUpdates.inventory_item_id = updates.inventoryItemId;

        const { data, error } = await supabase
            .from("shopping_list")
            .update(dbUpdates)
            .eq("id", id)
            .select()
            .single();

        if (error) throw new Error(`Failed to update shopping item: ${error.message}`);
        if (!data) throw new Error("No data returned from update operation");

        // Return the properly mapped data
        return mapDbToShoppingListItem(data as ShoppingListItemDB);
    } catch (err) {
        console.error("Error in updateShoppingItem:", err);
        throw err;
    }
}

/**
 * Deletes a shopping list item by id
 */
export async function deleteShoppingItem(id: string): Promise<boolean> {
    try {
        const { error } = await supabase
            .from("shopping_list")
            .delete()
            .eq("id", id);

        if (error) throw new Error(`Failed to delete shopping item: ${error.message}`);
        return true;
    } catch (err) {
        console.error("Error in deleteShoppingItem:", err);
        throw err;
    }
}

/**
 * Marks a shopping list item as purchased or unpurchased
 */
export async function markItemAsPurchased(
    id: string,
    isPurchased: boolean
): Promise<ShoppingListItem> {
    try {
        const { data, error } = await supabase
            .from("shopping_list")
            .update({
                is_purchased: isPurchased,
                purchased_at: isPurchased ? new Date().toISOString() : null
            })
            .eq("id", id)
            .select()
            .single();

        if (error) throw new Error(`Failed to update purchase status: ${error.message}`);
        if (!data) throw new Error("No data returned from purchase status update");

        // Return the properly mapped data
        return mapDbToShoppingListItem(data as ShoppingListItemDB);
    } catch (err) {
        console.error("Error in markItemAsPurchased:", err);
        throw err;
    }
}

/**
 * Fetches unique ingredient categories from the database
 */
export async function fetchCategories(): Promise<string[]> {
    try {
        // Use a direct SQL query to fetch categories
        const { data, error } = await supabase
            .from("ingredients")
            .select("category")
            .order("category");

        if (error) {
            console.warn("Error fetching categories from ingredients:", error.message);

            // If that fails, return a default set of categories
            return [
                "Meat",
                "Seafood",
                "Produce",
                "Dairy",
                "Dry Goods",
                "Bakery",
                "Beverages",
                "Other"
            ];
        }

        // Extract unique categories
        const uniqueCategories = [...new Set(data.map((item: { category: string }) =>
            item.category).filter(Boolean))];

        // If no categories found, return defaults
        if (!uniqueCategories.length) {
            return [
                "Meat",
                "Seafood",
                "Produce",
                "Dairy",
                "Dry Goods",
                "Bakery",
                "Beverages",
                "Other"
            ];
        }

        return uniqueCategories;
    } catch (err) {
        console.error("Error in fetchCategories:", err);
        // Return default categories as fallback
        return [
            "Meat",
            "Seafood",
            "Produce",
            "Dairy",
            "Dry Goods",
            "Bakery",
            "Beverages",
            "Other"
        ];
    }
}

/**
 * Generates a shopping list based on low inventory items
 */
export async function generateShoppingList(): Promise<ShoppingListItem[]> {
    try {
        // Fetch inventory items that are low in stock
        const { data: inventoryItems, error: inventoryError } = await supabase
            .from("ingredients")
            .select("*");

        if (inventoryError) throw new Error(`Failed to fetch ingredients: ${inventoryError.message}`);
        if (!inventoryItems) throw new Error("No inventory items found");

        // Find items that are below or at reorder level
        const lowStockItems = inventoryItems.filter(
            (item) => item.quantity <= (item.reorder_level || 0)
        );

        // Create shopping list items from low stock items
        const autoGeneratedItems: ShoppingListItem[] = [];

        for (const item of lowStockItems) {
            // Calculate how much to order (reorderLevel * 2 - current quantity)
            const orderQuantity = Math.max(
                Math.round(((item.reorder_level || 0) * 2 - item.quantity) * 10) / 10,
                0
            );

            if (orderQuantity <= 0) continue;

            // Check if this item already exists in the shopping list
            const { data: existingItems, error: checkError } = await supabase
                .from('shopping_list')
                .select('*')
                .eq('inventory_item_id', item.id)
                .eq('is_purchased', false)
                .eq('is_auto_generated', true);

            if (checkError) {
                console.error('Error checking existing shopping list items:', checkError);
                continue;
            }

            // If the item doesn't exist, add it to the shopping list
            if (!existingItems || existingItems.length === 0) {
                const { data: newItem, error: insertError } = await supabase
                    .from('shopping_list')
                    .insert({
                        inventory_item_id: item.id,
                        name: item.name,
                        quantity: orderQuantity,
                        unit: item.unit,
                        estimated_cost: Number((item.cost || 0) * orderQuantity).toFixed(2),
                        category: item.category,
                        is_auto_generated: true,
                        is_purchased: false,
                        added_at: new Date().toISOString(),
                    })
                    .select()
                    .single();

                if (insertError) {
                    console.error('Error adding item to shopping list:', insertError);
                    continue;
                }

                if (newItem) {
                    autoGeneratedItems.push(mapDbToShoppingListItem(newItem));
                }
            } else {
                autoGeneratedItems.push(mapDbToShoppingListItem(existingItems[0]));
            }
        }

        return autoGeneratedItems;
    } catch (err) {
        console.error("Error in generateShoppingList:", err);
        throw err;
    }
}