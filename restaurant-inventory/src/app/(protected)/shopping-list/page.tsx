// page.tsx
"use client";

import React, { useState, useRef, useEffect, useMemo } from "react";
import { QueryClient, QueryClientProvider } from "@tanstack/react-query";
import { useShoppingList } from "./hooks/useShoppingList";
import ShoppingListModals from "./components/modals";
import ShoppingListCharts from "./components/ShoppingListCharts";
import AccessibilityHelpers from "./components/AccessibilityHelpers";
import { ShoppingListItem } from "@/lib/types";
import {
  Undo,
  PlusCircle,
  RefreshCw,
  AlertTriangle,
  ListFilter,
  BarChart3,
} from "lucide-react";
import { motion, AnimatePresence } from "framer-motion";
import { announcer } from "./components/ScreenReaderAnnouncer";
import { toast } from "./utils/toast";
import ShoppingListSummary from "./components/ShoppingListSummary";
import EmptyShoppingList from "./components/EmptyShoppingList";
import {
  Card,
  CardContent,
  CardDescription,
  CardFooter,
  CardHeader,
  CardTitle,
} from "@/components/ui/card";
import { Button } from "@/components/ui/button";
import {
  Tooltip,
  TooltipContent,
  TooltipProvider,
  TooltipTrigger,
} from "@/components/ui/tooltip";

// Import our new components
import SearchFilterBar from "./components/SearchFilterBar";
import BatchActionsBar from "./components/BatchActionsBar";
import EnhancedShoppingListTable from "./components/EnhancedShoppingListTable";

// Create a client
const queryClient = new QueryClient();

// Wrap the main content in the QueryClientProvider
export default function ShoppingListPage() {
  return (
    <QueryClientProvider client={queryClient}>
      <ShoppingListContent />
    </QueryClientProvider>
  );
}

function ShoppingListContent() {
  const [selectedItem, setSelectedItem] = useState<ShoppingListItem | null>(
    null
  );
  const [isAddModalOpen, setIsAddModalOpen] = useState(false);
  const [isEditModalOpen, setIsEditModalOpen] = useState(false);
  const [searchTerm, setSearchTerm] = useState("");
  const [selectedCategory, setSelectedCategory] = useState<string>("all");
  const [showPurchased, setShowPurchased] = useState(false);
  const [sortBy, setSortBy] = useState("date");
  const [sortDirection, setSortDirection] = useState<"asc" | "desc">("desc");
  const [showAnalytics, setShowAnalytics] = useState(false);
  const [lastAction, setLastAction] = useState<{
    type: string;
    item?: ShoppingListItem;
    id?: string;
  }>({ type: "" });
  const undoTimeoutRef = useRef<NodeJS.Timeout | null>(null);

  // State for batch selection
  const [selectedItems, setSelectedItems] = useState<ShoppingListItem[]>([]);

  const {
    shoppingList,
    categories,
    isLoading,
    error,
    addItem,
    updateItem,
    removeItem,
    markAsPurchased,
    generateList,
    isAddingItem,
    isUpdatingItem,
    isDeletingItem,
    isMarkingAsPurchased,
    isGeneratingList,
  } = useShoppingList();

  // Derived data
  const pendingItems = useMemo(
    () => shoppingList.filter((item) => !item.isPurchased),
    [shoppingList]
  );

  const purchasedItems = useMemo(
    () => shoppingList.filter((item) => item.isPurchased),
    [shoppingList]
  );

  const urgentItems = useMemo(
    () => shoppingList.filter((item) => item.isUrgent),
    [shoppingList]
  );

  const autoGeneratedItems = useMemo(
    () => shoppingList.filter((item) => item.isAutoGenerated),
    [shoppingList]
  );

  const shoppingPhase = useMemo(() => {
    if (pendingItems.length === 0) return "complete";
    if (pendingItems.length > 0 && purchasedItems.length > 0)
      return "in-progress";
    if (pendingItems.length > 0 && purchasedItems.length === 0)
      return "planning";
    return "empty";
  }, [pendingItems.length, purchasedItems.length]);

  // Filter and sort logic
  const filteredList = useMemo(
    () =>
      shoppingList.filter((item) => {
        const matchesSearch = item.name
          .toLowerCase()
          .includes(searchTerm.toLowerCase());
        const matchesCategory =
          selectedCategory === "all" || item.category === selectedCategory;
        const matchesPurchased = showPurchased ? true : !item.isPurchased;
        return matchesSearch && matchesCategory && matchesPurchased;
      }),
    [shoppingList, searchTerm, selectedCategory, showPurchased]
  );

  const sortedList = useMemo(
    () =>
      [...filteredList].sort((a, b) => {
        let comparison = 0;

        if (sortBy === "name") comparison = a.name.localeCompare(b.name);
        else if (sortBy === "category")
          comparison = a.category.localeCompare(b.category);
        else if (sortBy === "cost")
          comparison = a.estimatedCost - b.estimatedCost;
        else if (sortBy === "quantity") comparison = a.quantity - b.quantity;
        else if (sortBy === "urgency")
          comparison = a.isUrgent === b.isUrgent ? 0 : a.isUrgent ? -1 : 1;
        else
          comparison =
            new Date(b.addedAt).getTime() - new Date(a.addedAt).getTime(); // date sort

        return sortDirection === "asc" ? comparison : -comparison;
      }),
    [filteredList, sortBy, sortDirection]
  );

  // Total cost calculation
  const totalEstimatedCost = useMemo(
    () => shoppingList.reduce((sum, item) => sum + item.estimatedCost, 0),
    [shoppingList]
  );

  // Check if there are any pending operations
  const isPending =
    isAddingItem ||
    isUpdatingItem ||
    isDeletingItem ||
    isMarkingAsPurchased ||
    isGeneratingList;

  // Item management handlers
  const handleAddItem = () => {
    setSelectedItem(null);
    setIsAddModalOpen(true);
  };

  const handleEditItem = (item: ShoppingListItem) => {
    setSelectedItem(item);
    setIsEditModalOpen(true);
  };

  const handleDeleteItem = async (id: string) => {
    const itemToDelete = shoppingList.find((item) => item.id === id);
    await removeItem(id);

    if (itemToDelete) {
      setLastAction({ type: "delete", item: itemToDelete });

      // Clear any existing timeout
      if (undoTimeoutRef.current) {
        clearTimeout(undoTimeoutRef.current);
      }

      // Show toast with undo button
      toast.info(
        <div className="flex items-center gap-2">
          <span>Item deleted</span>
          <button
            onClick={handleUndoLastAction}
            className="flex items-center gap-1 px-2 py-1 text-sm bg-gray-100 rounded hover:bg-gray-200"
          >
            <Undo className="h-3 w-3" />
            Undo
          </button>
        </div>,
        {
          duration: 5000,
          screenReaderMessage: `${itemToDelete.name} deleted. Press the undo button to restore it.`,
          onDismiss: () => {
            // Reset last action when toast dismisses
            setLastAction({ type: "" });
          },
        }
      );

      // Set timeout to clear the last action
      undoTimeoutRef.current = setTimeout(() => {
        setLastAction({ type: "" });
      }, 5000);
    }
  };

  const handleTogglePurchased = async (id: string, isPurchased: boolean) => {
    const targetItem = shoppingList.find((item) => item.id === id);
    await markAsPurchased({ id, isPurchased });

    if (targetItem) {
      setLastAction({
        type: "purchase",
        id,
        item: targetItem,
      });

      // Clear any existing timeout
      if (undoTimeoutRef.current) {
        clearTimeout(undoTimeoutRef.current);
      }

      // Show toast with undo button
      toast.info(
        <div className="flex items-center gap-2">
          <span>
            {isPurchased ? "Marked as purchased" : "Marked as not purchased"}
          </span>
          <button
            onClick={handleUndoLastAction}
            className="flex items-center gap-1 px-2 py-1 text-sm bg-gray-100 rounded hover:bg-gray-200"
          >
            <Undo className="h-3 w-3" />
            Undo
          </button>
        </div>,
        {
          duration: 5000,
          screenReaderMessage: `${targetItem.name} ${
            isPurchased ? "marked as purchased" : "marked as not purchased"
          }. Press the undo button to revert.`,
          onDismiss: () => {
            // Reset last action when toast dismisses
            setLastAction({ type: "" });
          },
        }
      );

      // Set timeout to clear the last action
      undoTimeoutRef.current = setTimeout(() => {
        setLastAction({ type: "" });
      }, 5000);
    }
  };

  const handleUndoLastAction = async () => {
    if (lastAction.type === "delete" && lastAction.item) {
      await addItem({
        name: lastAction.item.name,
        quantity: lastAction.item.quantity,
        unit: lastAction.item.unit,
        category: lastAction.item.category,
        estimatedCost: lastAction.item.estimatedCost,
        isUrgent: lastAction.item.isUrgent,
        notes: lastAction.item.notes,
        isPurchased: lastAction.item.isPurchased,
        isAutoGenerated: lastAction.item.isAutoGenerated,
      });

      toast.success("Item restored successfully", {
        screenReaderMessage: `${lastAction.item.name} has been restored to the list.`,
      });
    } else if (
      lastAction.type === "purchase" &&
      lastAction.id &&
      lastAction.item
    ) {
      const newPurchaseState = !lastAction.item.isPurchased;
      await markAsPurchased({
        id: lastAction.id,
        isPurchased: newPurchaseState,
      });

      toast.success(
        `Item ${newPurchaseState ? "purchased" : "unpurchased"} state restored`,
        {
          screenReaderMessage: `${lastAction.item.name} has been ${
            newPurchaseState ? "marked as purchased" : "marked as not purchased"
          }.`,
        }
      );
    }

    // Clear the last action
    setLastAction({ type: "" });

    // Clear any existing timeout
    if (undoTimeoutRef.current) {
      clearTimeout(undoTimeoutRef.current);
      undoTimeoutRef.current = null;
    }
  };

  const handleGenerateList = async () => {
    await generateList();
    toast.success("Shopping list generated successfully");
  };

  // Handle toggling the analytics view
  const toggleAnalytics = () => {
    setShowAnalytics(!showAnalytics);

    // Announce to screen readers
    announcer.announce(
      `${!showAnalytics ? "Showing" : "Hiding"} analytics section`,
      "polite"
    );
  };

  // Clear all filters
  const clearFilters = () => {
    setSearchTerm("");
    setSelectedCategory("all");
    setSortBy("date");
    setSortDirection("desc");

    // Don't reset showPurchased as this is often a persistent preference

    toast.info("Filters cleared");
  };

  // Batch actions handlers
  const handleMarkSelectedPurchased = async (ids: string[]) => {
    for (const id of ids) {
      await markAsPurchased({ id, isPurchased: true });
    }

    toast.success(`${ids.length} items marked as purchased`);
    setSelectedItems([]);
  };

  const handleMarkSelectedUnpurchased = async (ids: string[]) => {
    for (const id of ids) {
      await markAsPurchased({ id, isPurchased: false });
    }

    toast.success(`${ids.length} items marked as unpurchased`);
    setSelectedItems([]);
  };

  const handleDeleteSelected = async (ids: string[]) => {
    for (const id of ids) {
      await removeItem(id);
    }

    toast.success(`${ids.length} items deleted`);
    setSelectedItems([]);
  };

  const handleMarkSelectedUrgent = async (ids: string[]) => {
    for (const id of ids) {
      const item = shoppingList.find((item) => item.id === id);
      if (item) {
        await updateItem({
          id,
          updates: { isUrgent: true },
        });
      }
    }

    toast.success(`${ids.length} items marked as urgent`);
    setSelectedItems([]);
  };

  const handleMarkSelectedNotUrgent = async (ids: string[]) => {
    for (const id of ids) {
      const item = shoppingList.find((item) => item.id === id);
      if (item) {
        await updateItem({
          id,
          updates: { isUrgent: false },
        });
      }
    }

    toast.success(`${ids.length} items marked as not urgent`);
    setSelectedItems([]);
  };

  // Cleanup timeouts on unmount
  useEffect(() => {
    return () => {
      if (undoTimeoutRef.current) {
        clearTimeout(undoTimeoutRef.current);
      }
    };
  }, []);

  // Clear selected items when filter changes
  useEffect(() => {
    setSelectedItems([]);
  }, [searchTerm, selectedCategory, showPurchased]);

  if (isLoading) {
    return (
      <div className="flex items-center justify-center min-h-[60vh]">
        <div className="flex flex-col items-center gap-4">
          <div className="h-10 w-10 border-t-2 border-b-2 border-blue-600 rounded-full animate-spin"></div>
          <p className="text-lg font-medium text-gray-700">
            Loading shopping list...
          </p>
        </div>
      </div>
    );
  }

  if (error) {
    return (
      <div className="flex items-center justify-center min-h-[60vh]">
        <Card className="w-full max-w-md">
          <CardHeader className="bg-red-50">
            <CardTitle className="text-red-600 flex items-center gap-2">
              <AlertTriangle className="h-6 w-6" />
              Error Loading Shopping List
            </CardTitle>
          </CardHeader>
          <CardContent className="pt-4">
            <p>{error.message || "Please try again later"}</p>
          </CardContent>
          <CardFooter>
            <Button
              variant="outline"
              onClick={() => window.location.reload()}
              className="w-full"
            >
              Try Again
            </Button>
          </CardFooter>
        </Card>
      </div>
    );
  }

  return (
    <motion.div
      initial={{ opacity: 0 }}
      animate={{ opacity: 1 }}
      transition={{ duration: 0.3 }}
      className="container mx-auto px-4 py-8 space-y-6 max-w-7xl"
      aria-labelledby="page-heading"
    >
      <h1 id="page-heading" className="sr-only">
        Shopping List Management
      </h1>

      {/* Header Section with Main Actions */}
      <div className="flex flex-col lg:flex-row justify-between items-start lg:items-center gap-4">
        <div>
          <h2 className="text-3xl font-bold text-gray-900">Shopping List</h2>
          <p className="text-gray-500 mt-1">
            Manage your shopping items efficiently
          </p>
        </div>

        <div className="flex flex-wrap gap-3">
          <TooltipProvider>
            <Tooltip>
              <TooltipTrigger asChild>
                <Button
                  onClick={handleAddItem}
                  size="default"
                  className="bg-blue-600 hover:bg-blue-700"
                >
                  <PlusCircle className="h-4 w-4 mr-2" />
                  Add Item
                </Button>
              </TooltipTrigger>
              <TooltipContent>
                Add a new item to your shopping list
              </TooltipContent>
            </Tooltip>
          </TooltipProvider>

          <TooltipProvider>
            <Tooltip>
              <TooltipTrigger asChild>
                <Button
                  onClick={handleGenerateList}
                  variant="outline"
                  size="default"
                  disabled={isGeneratingList}
                >
                  <RefreshCw
                    className={`h-4 w-4 mr-2 ${
                      isGeneratingList ? "animate-spin" : ""
                    }`}
                  />
                  {isGeneratingList ? "Generating..." : "Generate List"}
                </Button>
              </TooltipTrigger>
              <TooltipContent>
                Auto-generate a shopping list based on your history
              </TooltipContent>
            </Tooltip>
          </TooltipProvider>

          <TooltipProvider>
            <Tooltip>
              <TooltipTrigger asChild>
                <Button
                  onClick={toggleAnalytics}
                  variant="ghost"
                  size="default"
                >
                  <BarChart3 className="h-4 w-4 mr-2" />
                  {showAnalytics ? "Hide Analytics" : "Show Analytics"}
                </Button>
              </TooltipTrigger>
              <TooltipContent>
                {showAnalytics ? "Hide" : "View"} shopping analytics and
                insights
              </TooltipContent>
            </Tooltip>
          </TooltipProvider>
        </div>
      </div>

      {/* Summary Cards */}
      <ShoppingListSummary
        itemsCount={{
          total: shoppingList.length,
          purchased: purchasedItems.length,
          urgent: urgentItems.length,
          autoGenerated: autoGeneratedItems.length,
        }}
        totalEstimatedCost={totalEstimatedCost}
        shoppingPhase={shoppingPhase}
      />

      {/* Search and Filter Bar */}
      <SearchFilterBar
        searchTerm={searchTerm}
        onSearchChange={setSearchTerm}
        selectedCategory={selectedCategory}
        onCategoryChange={setSelectedCategory}
        showPurchased={showPurchased}
        onShowPurchasedChange={setShowPurchased}
        categories={categories}
        sortBy={sortBy}
        onSortChange={setSortBy}
        sortDirection={sortDirection}
        onSortDirectionChange={setSortDirection}
        onClearFilters={clearFilters}
      />

      {/* Main Shopping List */}
      <Card className="shadow-sm relative">
        <CardHeader className="pb-0">
          <div className="flex justify-between items-center">
            <div>
              <CardTitle>Shopping Items</CardTitle>
              <CardDescription>
                {filteredList.length === 0
                  ? "No items match your current filters"
                  : `Showing ${filteredList.length} item${
                      filteredList.length === 1 ? "" : "s"
                    }`}
              </CardDescription>
            </div>
          </div>
        </CardHeader>
        <CardContent>
          {shoppingList.length === 0 ? (
            <EmptyShoppingList
              onAddClick={handleAddItem}
              onRefreshClick={handleGenerateList}
            />
          ) : filteredList.length === 0 ? (
            <div className="flex flex-col items-center justify-center py-12 text-center">
              <ListFilter className="h-12 w-12 text-gray-300 mb-4" />
              <h3 className="text-lg font-medium text-gray-700">
                No matching items
              </h3>
              <p className="text-gray-500 max-w-md mt-2">
                Try changing your search terms or filters to see more items
              </p>
              <Button variant="outline" onClick={clearFilters} className="mt-4">
                Clear All Filters
              </Button>
            </div>
          ) : (
            <EnhancedShoppingListTable
              items={sortedList}
              onEditItem={handleEditItem}
              onDeleteItem={handleDeleteItem}
              onTogglePurchased={handleTogglePurchased}
              onAddItem={handleAddItem}
              sortBy={sortBy}
              sortDirection={sortDirection}
              onSortChange={setSortBy}
              onSortDirectionChange={setSortDirection}
              isDeleting={isDeletingItem}
              isUpdating={isUpdatingItem || isMarkingAsPurchased}
              selectedItems={selectedItems}
              setSelectedItems={setSelectedItems}
            />
          )}
        </CardContent>
      </Card>

      {/* Analytics Section (Conditionally Shown) */}
      <AnimatePresence>
        {showAnalytics && (
          <motion.div
            initial={{ opacity: 0, height: 0 }}
            animate={{ opacity: 1, height: "auto" }}
            exit={{ opacity: 0, height: 0 }}
            transition={{ duration: 0.3 }}
            className="overflow-hidden"
          >
            <Card className="shadow-sm">
              <CardHeader>
                <CardTitle className="flex justify-between items-center">
                  <span>Shopping Analytics</span>
                  <Button variant="ghost" size="sm" onClick={toggleAnalytics}>
                    Hide
                  </Button>
                </CardTitle>
                <CardDescription>
                  Insights and trends from your shopping habits
                </CardDescription>
              </CardHeader>
              <CardContent>
                <ShoppingListCharts items={shoppingList} />
              </CardContent>
            </Card>
          </motion.div>
        )}
      </AnimatePresence>

      {/* Batch Actions Bar (shows when items are selected) */}
      <AnimatePresence>
        {selectedItems.length > 0 && (
          <BatchActionsBar
            selectedItems={selectedItems}
            onClearSelection={() => setSelectedItems([])}
            onMarkAllPurchased={handleMarkSelectedPurchased}
            onMarkAllUnpurchased={handleMarkSelectedUnpurchased}
            onDeleteAll={handleDeleteSelected}
            onMarkAllUrgent={handleMarkSelectedUrgent}
            onMarkAllNotUrgent={handleMarkSelectedNotUrgent}
            isProcessing={isPending}
          />
        )}
      </AnimatePresence>

      {/* Modals */}
      <ShoppingListModals
        isAddModalOpen={isAddModalOpen}
        isEditModalOpen={isEditModalOpen}
        selectedItem={selectedItem}
        onCloseAddModal={() => setIsAddModalOpen(false)}
        onCloseEditModal={() => setIsEditModalOpen(false)}
        onAdd={async (item) => {
          // Use a type assertion to ensure the item is of the expected type
          await addItem(
            item as Omit<
              ShoppingListItem,
              "id" | "addedAt" | "purchasedAt" | "userId" | "businessProfileId"
            >
          );
        }}
        onUpdate={async (updates) => {
          if (selectedItem) {
            await updateItem({ id: selectedItem.id, updates });
          }
        }}
        categories={categories}
        isSubmitting={isAddingItem || isUpdatingItem}
      />

      {/* Accessibility Helpers (Keep at the bottom) */}
      <AccessibilityHelpers
        items={sortedList}
        onItemSelect={handleEditItem}
        onItemPurchase={(params: { id: string; isPurchased: boolean }) => {
          return markAsPurchased(params).then(() => {});
        }}
      />
    </motion.div>
  );
}
