// page.tsx
"use client";

import { FC, useState, useCallback, useMemo } from "react";
import { QueryClient, QueryClientProvider } from "@tanstack/react-query";
import { useShoppingList } from "./hooks/useShoppingList";
import ShoppingListTable from "./components/ShoppingListTable";
import ShoppingListHeader from "./components/ShoppingListHeader";
import ShoppingListSummary from "./components/ShoppingListSummary";
import ShoppingListModals from "./components/modals";
import { ShoppingListItem } from "@/lib/types";
import { toast } from "sonner";
import { ShoppingListWrapper } from "./components/ShoppingListWrapper";
import { ShoppingListTabs } from "./components/ShoppingListTabs";
import ShoppingListActions from "./components/ShoppingListActions";
import ResponsiveHelpers from "./components/ResponsiveHelpers";
import { ScreenReaderAnnouncer } from "./components/ScreenReaderAnnouncer";

// Create a client with proper configuration
const queryClient = new QueryClient({
  defaultOptions: {
    queries: {
      staleTime: 5 * 60 * 1000, // 5 minutes
      retry: 1,
    },
  },
});

/**
 * Main wrapper component for the Shopping List page
 */
export default function ShoppingListPage() {
  return (
    <QueryClientProvider client={queryClient}>
      <ShoppingListContent />
    </QueryClientProvider>
  );
}

/**
 * Main Shopping List content component
 */
const ShoppingListContent: FC = () => {
  // Modal and item selection state
  const [selectedItem, setSelectedItem] = useState<ShoppingListItem | null>(
    null
  );
  const [isAddModalOpen, setIsAddModalOpen] = useState(false);
  const [isEditModalOpen, setIsEditModalOpen] = useState(false);

  // Filter state
  const [searchTerm, setSearchTerm] = useState("");
  const [selectedCategory, setSelectedCategory] = useState<string>("all");
  const [sortBy, setSortBy] = useState("date");
  const [filterBy, setFilterBy] = useState("all");
  const [activeTab, setActiveTab] = useState("all");

  // Fetch shopping list data using the custom hook
  const {
    shoppingList,
    categories,
    isLoading,
    error,
    addItem,
    updateItem,
    removeItem,
    markAsPurchased,
    generateList,
    isAddingItem,
    isUpdatingItem,
    isDeletingItem,
    isMarkingAsPurchased,
    isGeneratingList,
    refetch,
  } = useShoppingList();

  // Filter shopping list items based on search and filters
  const filteredList = useMemo(() => {
    if (!shoppingList.length) return [];

    return shoppingList.filter((item) => {
      const matchesSearch = item.name
        .toLowerCase()
        .includes(searchTerm.toLowerCase());

      const matchesCategory =
        selectedCategory === "all" || item.category === selectedCategory;

      const matchesFilter = (() => {
        switch (filterBy) {
          case "pending":
            return !item.isPurchased;
          case "purchased":
            return item.isPurchased;
          case "urgent":
            return item.isUrgent;
          case "auto":
            return item.isAutoGenerated;
          case "manual":
            return !item.isAutoGenerated;
          case "all":
          default:
            return true;
        }
      })();

      return matchesSearch && matchesCategory && matchesFilter;
    });
  }, [shoppingList, searchTerm, selectedCategory, filterBy]);

  // Sort the filtered list
  const sortedList = useMemo(() => {
    if (!filteredList.length) return [];

    return [...filteredList].sort((a, b) => {
      switch (sortBy) {
        case "name":
          return a.name.localeCompare(b.name);
        case "category":
          return a.category.localeCompare(b.category);
        case "cost":
          return a.estimatedCost - b.estimatedCost;
        case "quantity":
          return a.quantity - b.quantity;
        case "date":
        default:
          return (
            new Date(b.addedAt || 0).getTime() -
            new Date(a.addedAt || 0).getTime()
          );
      }
    });
  }, [filteredList, sortBy]);

  // Calculate summary statistics
  const summaryStats = useMemo(() => {
    const totalItems = shoppingList.length;
    const purchasedItems = shoppingList.filter(
      (item) => item.isPurchased
    ).length;
    const urgentItems = shoppingList.filter((item) => item.isUrgent).length;
    const autoGeneratedItems = shoppingList.filter(
      (item) => item.isAutoGenerated
    ).length;
    const totalCost = shoppingList.reduce(
      (sum, item) => sum + (item.estimatedCost || 0),
      0
    );

    return {
      total: totalItems,
      purchased: purchasedItems,
      urgent: urgentItems,
      autoGenerated: autoGeneratedItems,
      totalCost,
    };
  }, [shoppingList]);

  // Handler functions
  const handleAddItem = useCallback(() => {
    setSelectedItem(null);
    setIsAddModalOpen(true);
  }, []);

  const handleEditItem = useCallback((item: ShoppingListItem) => {
    setSelectedItem(item);
    setIsEditModalOpen(true);
  }, []);

  const handleDeleteItem = useCallback(
    async (id: string) => {
      try {
        await removeItem(id);
      } catch (error) {
        console.error("Error deleting item:", error);
      }
    },
    [removeItem]
  );

  const handleTogglePurchased = useCallback(
    async (id: string, isPurchased: boolean) => {
      try {
        await markAsPurchased({ id, isPurchased });
      } catch (error) {
        console.error("Error marking item as purchased:", error);
      }
    },
    [markAsPurchased]
  );

  const handleGenerateList = useCallback(async () => {
    try {
      const newItems = await generateList();
      if (newItems.length === 0) {
        toast.info("No new items needed. Your inventory is well-stocked!");
      }
    } catch (error) {
      console.error("Error generating shopping list:", error);
    }
  }, [generateList]);

  const handleAddItemSubmit = useCallback(
    async (item: Partial<ShoppingListItem>) => {
      try {
        await addItem(
          item as Omit<
            ShoppingListItem,
            "id" | "addedAt" | "purchasedAt" | "businessProfileId" | "userId"
          >
        );
        setIsAddModalOpen(false);
      } catch (error) {
        console.error("Error adding item:", error);
      }
    },
    [addItem]
  );

  const handleEditItemSubmit = useCallback(
    async (updates: Partial<ShoppingListItem>) => {
      if (!selectedItem) return;

      try {
        await updateItem({ id: selectedItem.id, updates });
        setIsEditModalOpen(false);
        setSelectedItem(null);
      } catch (error) {
        console.error("Error updating item:", error);
      }
    },
    [selectedItem, updateItem]
  );

  const handleTabChange = useCallback(
    (tab: string) => {
      setActiveTab(tab);

      // Update filter state based on tab
      if (tab === "add") {
        handleAddItem();
        return;
      }

      // Set the filter to match the tab
      setFilterBy(tab);
    },
    [handleAddItem]
  );

  // Render loading state
  if (isLoading) {
    return (
      <div className="container mx-auto py-6">
        <ShoppingListWrapper isLoading={true}>
          <div className="py-8"></div>
        </ShoppingListWrapper>
      </div>
    );
  }

  // Render error state
  if (error) {
    return (
      <div className="container mx-auto py-6">
        <ShoppingListWrapper
          title="Error"
          description="There was an error loading your shopping list."
        >
          <div className="p-6 text-center">
            <p className="text-red-500 mb-4">
              Error loading shopping list data
            </p>
            <button onClick={() => refetch()} className="btn btn-primary">
              Try Again
            </button>
          </div>
        </ShoppingListWrapper>
      </div>
    );
  }

  // Render main content
  return (
    <div className="container mx-auto py-8 space-y-6 px-4 sm:px-6">
      {/* Add accessibility components */}
      <ResponsiveHelpers />
      <ScreenReaderAnnouncer announcements={[]} politeAnnouncements={[]} />

      <div className="bg-white shadow-md rounded-xl p-4 md:p-6 border border-gray-100">
        <div className="flex flex-col md:flex-row justify-between items-start md:items-center gap-4 mb-6">
          <h1 className="text-2xl font-bold text-gray-800">Shopping List</h1>

          <ShoppingListActions
            onAddClick={handleAddItem}
            onGenerateClick={handleGenerateList}
            onExportClick={() => {}}
            isGenerating={isGeneratingList}
          />
        </div>

        <ShoppingListTabs activeTab={activeTab} onTabChange={handleTabChange} />
      </div>

      <ShoppingListHeader
        searchTerm={searchTerm}
        onSearchChange={setSearchTerm}
        selectedCategory={selectedCategory}
        onCategoryChange={setSelectedCategory}
        categories={categories}
        sortBy={sortBy}
        onSortChange={setSortBy}
      />

      <ShoppingListSummary
        totalItems={summaryStats.total}
        purchasedItems={summaryStats.purchased}
        urgentItems={summaryStats.urgent}
        autoGeneratedItems={summaryStats.autoGenerated}
        totalCost={summaryStats.totalCost}
      />

      <ShoppingListWrapper>
        <ShoppingListTable
          items={sortedList}
          onEditItem={handleEditItem}
          onDeleteItem={handleDeleteItem}
          onTogglePurchased={handleTogglePurchased}
          isDeleting={isDeletingItem}
          isUpdating={isUpdatingItem || isMarkingAsPurchased}
          onAddItem={handleAddItem}
        />
      </ShoppingListWrapper>

      <ShoppingListModals
        selectedItem={selectedItem}
        isAddModalOpen={isAddModalOpen}
        isEditModalOpen={isEditModalOpen}
        onCloseAddModal={() => setIsAddModalOpen(false)}
        onCloseEditModal={() => setIsEditModalOpen(false)}
        onAdd={handleAddItemSubmit}
        onUpdate={handleEditItemSubmit}
        categories={categories}
        isSubmitting={isAddingItem || isUpdatingItem}
      />
    </div>
  );
};
