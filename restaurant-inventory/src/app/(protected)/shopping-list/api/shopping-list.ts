import { supabase } from "@/lib/supabase";
import { ShoppingListItem, ShoppingListItemDB, mapDbToShoppingListItem } from "@/lib/types";

export async function fetchShoppingList() {
    try {
        // Since business_profile_id doesn\'t exist, just fetch all items
        const { data, error } = await supabase
            .from("shopping_list")
            .select(`
                id,
                name,
                quantity,
                unit,
                category,
                estimated_cost,
                is_auto_generated,
                is_purchased,
                inventory_item_id,
                added_at,
                purchased_at,
                user_id
            `)
            .order("added_at", { ascending: false });

        if (error) {
            console.error("Error in fetchShoppingList:", error.message);
            return [];
        }

        return data.map(item => mapDbToShoppingListItem(item as ShoppingListItemDB));
    } catch (err) {
        console.error("Error in fetchShoppingList:", err);
        return [];
    }
}

export async function createShoppingItem(
    item: Omit<ShoppingListItem, "id" | "addedAt" | "purchasedAt">
) {
    try {
        // Prepare the item data without business_profile_id
        const itemData = {
            name: item.name,
            quantity: item.quantity,
            unit: item.unit,
            category: item.category,
            estimated_cost: item.estimatedCost || 0, // Ensure this is never undefined
            is_auto_generated: item.isAutoGenerated ?? false,
            is_purchased: item.isPurchased ?? false,
            inventory_item_id: item.inventoryItemId || null,
            user_id: item.userId,
            added_at: new Date().toISOString()
        };

        const { data, error } = await supabase
            .from("shopping_list")
            .insert([itemData])
            .select()
            .single();

        if (error) {
            throw new Error(error.message);
        }

        // Make sure we return the properly mapped data
        return mapDbToShoppingListItem(data as ShoppingListItemDB);
    } catch (err) {
        console.error("Error in createShoppingItem:", err);
        throw err;
    }
}

export async function updateShoppingItem(
    id: string,
    updates: Partial<Omit<ShoppingListItem, "id" | "addedAt" | "purchasedAt">>
) {
    // Convert camelCase property names to snake_case for the database
    const dbUpdates: Record<string, string | number | boolean | null> = {};

    if (updates.name !== undefined) dbUpdates.name = updates.name;
    if (updates.quantity !== undefined) dbUpdates.quantity = updates.quantity;
    if (updates.unit !== undefined) dbUpdates.unit = updates.unit;
    if (updates.category !== undefined) dbUpdates.category = updates.category;
    if (updates.estimatedCost !== undefined) dbUpdates.estimated_cost = updates.estimatedCost;
    if (updates.isAutoGenerated !== undefined) dbUpdates.is_auto_generated = updates.isAutoGenerated;
    if (updates.isPurchased !== undefined) {
        dbUpdates.is_purchased = updates.isPurchased;
        if (updates.isPurchased) {
            dbUpdates.purchased_at = new Date().toISOString();
        }
    }
    if (updates.notes !== undefined) dbUpdates.notes = updates.notes;
    if (updates.inventoryItemId !== undefined) dbUpdates.inventory_item_id = updates.inventoryItemId;

    const { data, error } = await supabase
        .from("shopping_list")
        .update(dbUpdates)
        .eq("id", id)
        .select()
        .single();

    if (error) throw new Error(error.message);

    // Make sure we return the properly mapped data
    return mapDbToShoppingListItem(data as ShoppingListItemDB);
}

export async function deleteShoppingItem(id: string) {
    const { error } = await supabase
        .from("shopping_list")
        .delete()
        .eq("id", id);

    if (error) throw new Error(error.message);
    return true;
}

export async function markItemAsPurchased(
    id: string,
    isPurchased: boolean
) {
    const { data, error } = await supabase
        .from("shopping_list")
        .update({
            is_purchased: isPurchased,
            purchased_at: isPurchased ? new Date().toISOString() : null
        })
        .eq("id", id)
        .select()
        .single();

    if (error) throw new Error(error.message);

    // Make sure we return the properly mapped data
    return mapDbToShoppingListItem(data as ShoppingListItemDB);
}

export async function fetchCategories() {
    try {
        // Use a direct SQL query instead of the RPC function since it\'s failing
        const { data, error } = await supabase
            .from("ingredients")
            .select("category")
            .order("category");

        if (error) {
            console.warn("Error fetching categories from ingredients:", error.message);

            // If that fails, return a default set of categories
            return [
                "Meat",
                "Seafood",
                "Produce",
                "Dairy",
                "Dry Goods",
                "Bakery",
                "Beverages",
                "Other"
            ];
        }

        // Extract unique categories
        const uniqueCategories = [...new Set(data.map((item: { category: string }) => item.category).filter(Boolean))];

        // If no categories found, return defaults
        if (!uniqueCategories.length) {
            return [
                "Meat",
                "Seafood",
                "Produce",
                "Dairy",
                "Dry Goods",
                "Bakery",
                "Beverages",
                "Other"
            ];
        }

        return uniqueCategories;
    } catch (err) {
        console.error("Error in fetchCategories:", err);
        // Return default categories as fallback
        return [
            "Meat",
            "Seafood",
            "Produce",
            "Dairy",
            "Dry Goods",
            "Bakery",
            "Beverages",
            "Other"
        ];
    }
}

export async function generateShoppingList() {
    try {
        // Fetch inventory items that are low in stock
        const { data: inventoryItems, error: inventoryError } = await supabase
            .from("ingredients")
            .select("*");

        if (inventoryError) throw new Error(inventoryError.message);

        // Find items that are below or at reorder level
        const lowStockItems = inventoryItems.filter(
            (item) => item.quantity <= (item.reorder_level || 0)
        );

        // Create shopping list items from low stock items
        const autoGeneratedItems = [];

        for (const item of lowStockItems) {
            // Calculate how much to order (reorderLevel * 2 - current quantity)
            const orderQuantity = Math.max(
                Math.round(((item.reorder_level || 0) * 2 - item.quantity) * 10) / 10,
                0
            );

            if (orderQuantity <= 0) continue;

            // Check if this item already exists in the shopping list
            const { data: existingItems, error: checkError } = await supabase
                .from('shopping_list')
                .select('*')
                .eq('inventory_item_id', item.id)
                .eq('is_purchased', false)
                .eq('is_auto_generated', true);

            if (checkError) {
                console.error('Error checking existing shopping list items:', checkError);
                continue;
            }

            // Determine urgency based on current stock level
            // If stock is less than 25% of reorder level, mark as urgent
            const isUrgent = item.quantity <= (item.reorder_level || 0) * 0.25;

            // If the item doesn\'t exist, add it to the shopping list
            if (!existingItems || existingItems.length === 0) {
                const { data: newItem, error: insertError } = await supabase
                    .from('shopping_list')
                    .insert({
                        inventory_item_id: item.id,
                        name: item.name,
                        quantity: orderQuantity,
                        unit: item.unit,
                        estimated_cost: Number((item.cost || 0) * orderQuantity).toFixed(2),
                        category: item.category,
                        is_auto_generated: true,
                        is_purchased: false,
                        is_urgent: isUrgent,
                        added_at: new Date().toISOString(),
                    })
                    .select()
                    .single();

                if (insertError) {
                    console.error('Error adding item to shopping list:', insertError);
                    continue;
                }

                if (newItem) {
                    autoGeneratedItems.push(mapDbToShoppingListItem(newItem));
                }
            } else {
                // Update existing item\'s urgency status if needed
                const existingItem = existingItems[0];
                if (existingItem.is_urgent !== isUrgent) {
                    const { data: updatedItem, error: updateError } = await supabase
                        .from('shopping_list')
                        .update({ is_urgent: isUrgent })
                        .eq('id', existingItem.id)
                        .select()
                        .single();

                    if (updateError) {
                        console.error('Error updating item urgency:', updateError);
                        autoGeneratedItems.push(mapDbToShoppingListItem(existingItem));
                    } else if (updatedItem) {
                        autoGeneratedItems.push(mapDbToShoppingListItem(updatedItem));
                    }
                } else {
                    autoGeneratedItems.push(mapDbToShoppingListItem(existingItem));
                }
            }
        }

        return autoGeneratedItems;
    } catch (err) {
        console.error("Error in generateShoppingList:", err);
        throw err;
    }
}