import { ShoppingListItem, ShoppingListItemDB, mapDbToShoppingListItem, InventoryItem } from "@/lib/types";
import { supabase } from '@/lib/supabase';

// Shopping list service
export const shoppingListService = {
    // Get all shopping list items
    getItems: async (): Promise<ShoppingListItem[]> => {
        try {
            if (!supabase) {
                throw new Error('Supabase client is not initialized');
            }

            const { data, error } = await supabase
                .from('shopping_list')
                .select('*')
                .order('added_at', { ascending: false });

            if (error) {
                console.error('Error fetching shopping list items:', error);
                throw new Error(`Failed to fetch shopping list items: ${error.message}`);
            }

            if (!data) {
                return [];
            }

            return data.map((item: ShoppingListItemDB) => mapDbToShoppingListItem(item));
        } catch (error) {
            console.error('Error in getItems:', error);
            throw error;
        }
    },

    // Generate shopping list based on inventory items
    generateList: async (inventoryItems: InventoryItem[]): Promise<ShoppingListItem[]> => {
        try {
            if (!supabase) {
                throw new Error('Supabase client is not initialized');
            }

            // Find items that are below or at reorder level
            const lowStockItems = inventoryItems.filter(
                (item) => item.quantity <= (item.reorder_level || 0)
            );

            // Create shopping list items from low stock items
            const autoGeneratedItems: ShoppingListItem[] = [];

            for (const item of lowStockItems) {
                // Calculate how much to order (reorderLevel * 2 - current quantity)
                const orderQuantity = Math.max(
                    Math.round(((item.reorder_level || 0) * 2 - item.quantity) * 10) / 10,
                    0
                );

                if (orderQuantity <= 0) continue;

                // Check if this item already exists in the shopping list
                const { data: existingItems, error: checkError } = await supabase
                    .from('shopping_list')
                    .select('*')
                    .eq('inventory_item_id', item.id)
                    .eq('is_purchased', false)
                    .eq('is_auto_generated', true);

                if (checkError) {
                    console.error('Error checking existing shopping list items:', checkError);
                    continue;
                }

                // If the item doesn't exist, add it to the shopping list
                if (!existingItems || existingItems.length === 0) {
                    const { data: newItem, error: insertError } = await supabase
                        .from('shopping_list')
                        .insert({
                            inventory_item_id: item.id,
                            name: item.name,
                            quantity: orderQuantity,
                            unit: item.unit,
                            estimated_cost: (item.cost || 0) * orderQuantity,
                            category: item.category,
                            is_auto_generated: true,
                            is_purchased: false,
                            added_at: new Date().toISOString(),
                        })
                        .select()
                        .single();

                    if (insertError) {
                        console.error('Error adding item to shopping list:', insertError);
                        continue;
                    }

                    if (newItem) {
                        autoGeneratedItems.push(mapDbToShoppingListItem(newItem));
                    }
                } else {
                    // Item already exists in the shopping list
                    autoGeneratedItems.push(mapDbToShoppingListItem(existingItems[0]));
                }
            }

            return autoGeneratedItems;
        } catch (error) {
            console.error('Error in generateList:', error);
            throw error;
        }
    },

    // Add a new item to the shopping list
    addItem: async (item: Omit<ShoppingListItem, "id" | "addedAt">): Promise<ShoppingListItem> => {
        try {
            if (!supabase) {
                throw new Error('Supabase client is not initialized');
            }

            const dbData = {
                inventory_item_id: item.inventoryItemId ? item.inventoryItemId : null,
                name: item.name,
                quantity: item.quantity,
                unit: item.unit,
                estimated_cost: item.estimatedCost,
                category: item.category,
                notes: item.notes,
                is_auto_generated: item.isAutoGenerated,
                is_purchased: item.isPurchased,
                added_at: new Date().toISOString(),
                user_id: item.userId,
                business_profile_id: item.businessProfileId,
            };

            const { data, error } = await supabase
                .from('shopping_list')
                .insert(dbData)
                .select()
                .single();

            if (error) {
                console.error('Error adding shopping list item:', error);
                throw new Error(`Failed to add shopping list item: ${error.message}`);
            }

            if (!data) {
                throw new Error('No data returned after adding item');
            }

            return mapDbToShoppingListItem(data as ShoppingListItemDB);
        } catch (error) {
            console.error('Error in addItem:', error);
            throw error;
        }
    },

    // Mark an item as purchased
    markAsPurchased: async (itemId: string): Promise<ShoppingListItem> => {
        try {
            if (!supabase) {
                throw new Error('Supabase client is not initialized');
            }

            const { data, error } = await supabase
                .from('shopping_list')
                .update({
                    is_purchased: true,
                    purchased_at: new Date().toISOString(),
                })
                .eq('id', itemId)
                .select()
                .single();

            if (error) {
                console.error('Error marking item as purchased:', error);
                throw new Error(`Failed to mark item as purchased: ${error.message}`);
            }

            if (!data) {
                throw new Error('No data returned after updating item');
            }

            return mapDbToShoppingListItem(data as ShoppingListItemDB);
        } catch (error) {
            console.error('Error in markAsPurchased:', error);
            throw error;
        }
    },

    // Remove an item from the shopping list
    removeItem: async (itemId: string): Promise<void> => {
        try {
            if (!supabase) {
                throw new Error('Supabase client is not initialized');
            }

            const { error } = await supabase
                .from('shopping_list')
                .delete()
                .eq('id', itemId);

            if (error) {
                console.error('Error removing shopping list item:', error);
                throw new Error(`Failed to remove shopping list item: ${error.message}`);
            }
        } catch (error) {
            console.error('Error in removeItem:', error);
            throw error;
        }
    },

    // Update inventory based on purchased items
    updateInventory: async (purchasedItems: ShoppingListItem[]): Promise<void> => {
        try {
            if (!supabase) {
                throw new Error('Supabase client is not initialized');
            }

            // Get the authenticated user
            const { data: { user } } = await supabase.auth.getUser();

            if (!user) {
                console.error('No authenticated user found');
                throw new Error('User not authenticated');
            }

            // Get the user's business profile
            const { data: businessProfile, error: businessError } = await supabase
                .from('business_profiles')
                .select('id')
                .eq('user_id', user.id)
                .single();

            if (businessError || !businessProfile) {
                console.error('Error fetching business profile:', businessError);
                throw new Error('Business profile not found');
            }

            // Process each purchased item
            for (const item of purchasedItems) {
                if (!item.inventoryItemId) {
                    console.log('Skipping item without inventory ID:', item.name);
                    continue;
                }

                // Get current inventory item
                const { data: inventoryItem, error: fetchError } = await supabase
                    .from('ingredients')
                    .select('*')
                    .eq('id', item.inventoryItemId)
                    .eq('business_profile_id', businessProfile.id)
                    .single();

                if (fetchError || !inventoryItem) {
                    console.error('Error fetching inventory item:', fetchError);
                    continue;
                }

                // Update inventory quantity
                const { error: updateError } = await supabase
                    .from('ingredients')
                    .update({
                        quantity: inventoryItem.quantity + item.quantity,
                    })
                    .eq('id', item.inventoryItemId)
                    .eq('business_profile_id', businessProfile.id);

                if (updateError) {
                    console.error('Error updating inventory item:', updateError);
                }
            }
        } catch (error) {
            console.error('Error in updateInventory:', error);
            throw error;
        }
    },
};